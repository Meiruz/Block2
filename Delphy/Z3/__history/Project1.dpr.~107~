Program Laba3;

Uses
    SysUtils;

Type
    TErrors = (FailFileOpen = 0, FailFileCreateOrOpen, FailData,
        FailLimitOfData, NotTXTFile);
    TFile = (FileIn, FileOut, FileCons);
    TMatrix = Array Of Array Of Integer;
    TArray = Array of Integer;

Const
    ERRORS: Array [0 .. 4] Of String =
        ('Не удалось открыть файл или прочитать данные. Попробуйте еще раз, проверив путь и имя файла.',
        'Не удалось открыть или создать файл. Попробуйте еще раз, проверив путь и имя файла.',
        'Некорректные данные данные. Попробуйте еще раз.',
        'Ваше значение не соответствует числовым ограничениям. Попробуйте еще раз.',
        'Расширение файла должно быть TXT. Попробуйте еще раз.');
    MIN_LIMIT = -100;
    MAX_LIMIT = 100;
    MIN_LIMIT_SIZE = 0;
    MAX_LIMIT_SIZE = 100;

function checkNumForLimitError(num: integer; const MAX_LIMIT_NUM, MIN_LIMIT_NUM: integer): boolean;
Begin
    if (num > MAX_LIMIT_NUM) or (num < MIN_LIMIT_NUM) then
    begin
        Write(ERRORS[Ord(FailLimitOfData)]);
        checkNumForLimitError := false;
    end
    else
        checkNumForLimitError := false;
End;

function inWithChecking(Var InputFile: TextFile; Var Num: Integer;
    Const MAX_LIMIT_NUM, MIN_LIMIT_NUM: Integer; inType: integer): boolean;
Var
    IsFail: Boolean;
Begin
    IsFail := False;

    Try
        Read(InputFile, Num);
    Except
        Write(ERRORS[Ord(FailData)]);
        IsFail := True;
    end;

    if Not isFail then 
        isFail := checkNumForLimitError(Num, MAX_LIMIT_NUM, MIN_LIMIT_NUM);

    If (IsFail) and (inType = 1) Then
        inWithChecking(InputFile, Num, MAX_LIMIT, MIN_LIMIT, inType);
    
    if IsFail then
        inWithChecking := false
    else
        inWithChecking := true;
End;

Procedure strToLow(var str: string);
Var
    I, asciiValue: integer;
begin
    for I := 1 to High(str) do
    begin
        asciiValue := ord(str[i]);
        if (asciiValue > 64) and (asciiValue < 91) then
            str[i] := char(asciiValue + 32);
    end;         
end;

Function CheckFileNotTxt(PathToFile: String): Boolean;
Var
    StringLength: Integer;
Begin
    strToLow(PathToFile);

    StringLength := Length(PathToFile);

    If StringLength < 4 Then
        CheckFileNotTxt := True
    Else
    Begin
        If (PathToFile[StringLength] = 't') And
            (PathToFile[StringLength - 1] = 'x') And
            (PathToFile[StringLength - 2] = 't') And
            (PathToFile[StringLength - 3] = '.') Then
            CheckFileNotTxt := False
        Else
            CheckFileNotTxt := True;
    End;
End;

Procedure OpenFile(Var OpendFile: TextFile; FileType: TFile);
Var
    PathToFile: String;
    IsOk: Boolean;
Begin
    IsOk := True;

    If FileType = FileIn Then
        Writeln(#10#13, 'Введите путь к файлу .txt для ввода данных: ')
    Else
        Writeln(#10#13, 'Введите путь к файлу .txt для вывода данных: ');
    Readln(PathToFile);

    If CheckFileNotTxt(PathToFile) Then
    Begin
        Writeln(ERRORS[Ord(NotTXTFile)]);
        IsOk := False;
        OpenFile(OpendFile, FileType);
    End;

    If IsOk Then
        Try
            AssignFile(OpendFile, PathToFile);
            If FileType = FileIn Then
                Reset(OpendFile)
            Else
                Rewrite(OpendFile);
        Except
            If FileType = FileIn Then
                Writeln(ERRORS[Ord(FailFileOpen)])
            Else
                Writeln(ERRORS[Ord(FailFileCreateOrOpen)]);

            IsOk := False;
            OpenFile(OpendFile, FileType);
        End;
End;

Procedure InDataWithConsole(Var InputFile: textFile; Var M, N: Integer; Var Matrix: TMatrix);
Var
    I, J: Integer;
Begin
    AssignFile(InputFile, '');
    Reset(InputFile);

    Writeln('Введите колчество строк M матрицы: ');
    inWithChecking(InputFile, M, MAX_LIMIT_SIZE, MIN_LIMIT_SIZE, 1);

    Writeln('Введите колчество столбцов N матрицы: ');
    inWithChecking(InputFile, N, MAX_LIMIT_SIZE, MIN_LIMIT_SIZE, 1);

    SetLength(Matrix, M);
    For I := 0 To High(Matrix) Do
    Begin
        SetLength(Matrix[I], N);
        For J := 0 To High(Matrix[i]) Do
        begin
            Write('Введите элемент матрицы [', I, ', ', J, ']: ');
            inWithChecking(InputFile, matrix[i][j], MAX_LIMIT, MIN_LIMIT, 1);
        end;
    End;

    close(inputFile);
End;

function InDataWithFile(var InputFile: TextFile; Var M, N: Integer; Var Matrix: TMatrix): boolean;
Var
    I, J: Integer;
Begin
    OpenFile(InputFile, FileIn);

    if Not inWithChecking(InputFile, N, MAX_LIMIT_SIZE, MIN_LIMIT_SIZE, 2) then
    Begin
        InDataWithFile := false;
    End;

    if Not inWithChecking(InputFile, M, MAX_LIMIT_SIZE, MIN_LIMIT_SIZE, 2) then
    Begin
        InDataWithFile := false;
    End;

    SetLength(Matrix, M);
    For I := 0 To High(Matrix) Do
    Begin
        SetLength(Matrix[I], N);
        For J := 0 To High(Matrix[i]) Do
            if Not inWithChecking(InputFile, matrix[i][j], MAX_LIMIT, MIN_LIMIT, 2) then
            Begin
                InDataWithFile := false;
            End;
    End;

    InDataWithFile := true;
    close(inputFile);
End;

Procedure InData(Var M, N: Integer; Var Matrix: TMatrix; InType: Integer);
Var
    InputFile: TextFile;
    isDataOk: boolean;
Begin
    If InType = 1 Then  
        InDataWithConsole(InputFile, N, M, Matrix)
    else
        repeat
            isDataOk := InDataWithFile(InputFile, N, M, Matrix);
        until isDataOk;      
End;

Procedure FindSeddlePoints(var matrix: TMatrix; m, n, outType: integer);
var
    minRows, maxColumns: TArray;
    I, J: integer;
    outputFile: TextFile;
Begin
    if (outType = 2) then
        openFile(outputFile, FileOut);
    
    setLength(minRows, m);
    setLength(maxColumns, n);

    for I := 0 to High(minRows) do    
    begin
        minRows[i] := MAX_LIMIT + 1;
        maxColumns[i] := 0;
    end;
        
End;

procedure ExitProgram();
Begin
    Writeln('Для выхода из программы нажмите Enter...');
    Readln;
End;

Var
    N, M, InType, OutType: Integer;
    Matrix: TMatrix;
    ConsoleFile: TextFile;
Begin
    Writeln('Программа для определения "седловой" точки матрицы.');

    Writeln('Все значения матрицы должны быть от ', MIN_LIMIT, ' до ',
        MAX_LIMIT, '.');
    Writeln('Размеры матрицы MxN быть от ', MIN_LIMIT_SIZE, ' до ',
        MAX_LIMIT_SIZE, '.');

    Writeln('Введите предпочетаемый тип ввода данных: ');
    Writeln(#9, '1 - из консоли (по элементу),', #10#13#9,
        '2 - из файла (одна строка m и n, дальше элементы в виде таблицы).');

    AssignFile(ConsoleFile, '');
    Reset(ConsoleFile);
    inWithChecking(ConsoleFile, InType, 2, 1, 1);

    InData(M, N, Matrix, InType);

    for var i := 0 to High(matrix) do
    Begin
        for var j := 0 to High(matrix) do
            write(matrix[i, j]);  
        writeln;  
    End;    

    Writeln('Введите предпочетаемый тип вывода данных: ');
    Writeln(#9, '1 - только в консоли,,', #10#13#9,
        '2 - в консоль и в файл.');

    inWithChecking(ConsoleFile, OutType, 2, 1, 1);
    close(ConsoleFile);
        
    FindSeddlePoints(matrix, m, n, outType);

    ExitProgram();
End.
